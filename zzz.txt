

/** ---------------------------------
 *  OCR + PARSERS (ported from your originals, minor tidy)
 * ----------------------------------*/
const RE = {
  PO_NAME: /^PO_(\d+)/i,
  // allow SO12345.pdf, SO 12345.pdf, SO-12345.pdf (any case)
  SO_NAME: /^SO[\s_-]?\d+\.pdf$/i,
  PO_TOTAL: /Total\s+Amount:\s*US\$\s*([0-9]{1,3}(?:,[0-9]{3})*(?:\.[0-9]{2})?)/i
};

function ocrPdf(blob, lang) {
  const { MAX_RETRIES, COOLDOWN_MS, CACHE } = CONFIG.OCR;
  const md5  = Utilities.base64EncodeWebSafe(Utilities.computeDigest(Utilities.DigestAlgorithm.MD5, blob.getBytes()));
  const key  = `ocr:${md5}`;
  const cache = CacheService.getScriptCache();

  if (CACHE) {
    const hit = cache.get(key);
    if (hit) return hit;
  }

  let delay = 0;
  for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    if (delay) Utilities.sleep(delay);
    try {
      const { id } = Drive.Files.insert(
        { title: blob.getName(), mimeType: blob.getContentType() },
        blob,
        { ocr: true, ocrLanguage: lang, fields: 'id' }
      );
      const txt = DocumentApp.openById(id).getBody().getText();
      try { Drive.Files.remove(id); } catch (delErr) { Log.warn('Drive delete failed (ignored): %s', delErr); }
      if (CACHE) cache.put(key, txt, 86400);
      Utilities.sleep(COOLDOWN_MS);
      return txt;
    } catch (e) {
      if (!/rate limit/i.test(e.message) || attempt === MAX_RETRIES) throw e;
      delay = (1 << attempt) * 1000 + Math.random() * 500; // backoff + jitter
      Log.warn('OCR rate-limit; retry %d in %ds', attempt, Math.round(delay / 1000));
    }
  }
}

function parseOrderDetails(t) {
  const out = { orderNumber:null, estimatedShipDate:null, totalFreight:null, totalNet:null, invoiceNumber:null };
  let m;
  if (m = t.match(/\bN°\s*([A-Z0-9]+)/i)) out.orderNumber = (m[1] || '').replace(/^SO/i, '');
  if (m = t.match(/\bEstimated ship date\s*([\d/]{8})/i)) out.estimatedShipDate = m[1];
  if (m = t.match(/\bFreight\s*\$\s*([\d,]+\.[\d]{2})/i)) out.totalFreight = m[1].replace(/,/g,'');
  if (m = t.match(/\bTotal\s+Net\s*\$\s*([\d,]+\.[\d]{2})/i)) out.totalNet = m[1].replace(/,/g,'');
  if (m = t.match(/\b2363-(\d+)/)) out.invoiceNumber = m[1];
  return out;
}

function toDate(val) {
  if (!val) return '';
  const [a,b,c] = val.split('/').map(Number); // two-digit yy
  const yy = 2000 + c; let mm, dd;
  if (a > 12 && b <= 12) { dd = a; mm = b; }
  else if (b > 12)        { dd = b; mm = a; }
  else                    { dd = a; mm = b; }
  return new Date(yy, mm-1, dd);
}

function parseDMY(str) {
  if (typeof str !== 'string') return null;
  const m = str.trim().match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})$/);
  if (!m) return null; // m[1]=D, m[2]=M, m[3]=YYYY
  return new Date(+m[3], +m[2] - 1, +m[1]);
}

function toMMDDYY(str) {
  if (!str) return '';
  const m = str.match(/^(\d{2})\/(\d{2})\/(\d{2})$/);
  if (!m) return str;
  const d = +m[1], mo = +m[2];
  if (d > 12 && mo <= 12) return `${m[2]}/${m[1]}/${m[3]}`; // DD/MM → MM/DD
  if (mo > 12) return str;                                   // already MM/DD
  return `${m[2]}/${m[1]}/${m[3]}`;                           // default DD/MM
}

/** ---------------------------------
 *  SHEET UTILS
 * ----------------------------------*/
const SheetU = {
  openOrCreateTab(ssId, name, headers) {
    const ss = SpreadsheetApp.openById(ssId);
    let sh = ss.getSheetByName(name);
    if (!sh) sh = ss.insertSheet(name);
    if (headers && sh.getLastRow() === 0) {
      sh.appendRow(headers);
      sh.setFrozenRows(1);
    }
    return sh;
  },
  refreshExtruflexTable() {
    const ss    = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
    const sheet = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
    if (!sheet) { Log.err(`Sheet "${CONFIG.SHEETS.MAIN_TAB}" not found`); return; }

    let lastRow = sheet.getLastRow();
    const lastCol = sheet.getLastColumn();
    if (lastRow < 2) return;                          // no data rows

    // 1) delete rows where Cancelled (col K) is TRUE
    const CANCEL_COL = 11; // K
    const rng = sheet.getRange(2, CANCEL_COL, lastRow - 1, 1).getValues().flat();
    for (let i = rng.length - 1; i >= 0; i--) {
      if (rng[i] === true) sheet.deleteRow(i + 2);
    }

    // 2) sort by Sage Invoice # (col A)
    lastRow = sheet.getLastRow();
    if (lastRow < 2) return;
    sheet.getRange(2, 1, lastRow - 1, lastCol).sort({ column: 1, ascending: true });
  }
};

/** ---------------------------------
 *  EXTRUFLEX: CONFIRM POs (re-uses your logic, slightly trimmed)
 *  - kept as a module but calls shared utils
 * ----------------------------------*/
function confirmExtruflexPOs() {
  const lock = LockService.getScriptLock();
  if (!lock.tryLock(10000)) return Log.warn('Another run in progress');

  const FWD_LABEL = CONFIG.LABELS.EX_FWD;
  const CNF_LABEL = CONFIG.LABELS.EX_CNF;

  try {
    const fwd = GmailApp.getUserLabelByName(FWD_LABEL);
    if (!fwd) return Log.err(`label ${FWD_LABEL} missing`);
    const cnf = GmailU.getOrCreateLabel(CNF_LABEL);

    const sh = SheetU.openOrCreateTab(
      CONFIG.SHEETS.MAIN_ID,
      CONFIG.SHEETS.MAIN_TAB,
      ['Sage Invoice#','Document#','S Total','E Total','Freight','Est Ship']
    );

    const last = sh.getLastRow();
    const colA = last>=2 ? sh.getRange(2,1,last-1,1).getValues().flat() : [];
    const colB = last>=2 ? sh.getRange(2,2,last-1,1).getValues().flat() : [];
    const seenInv  = new Set(colA.map(String));
    const seenConf = new Set(colB.map(String));

    // 🔍 new: louder candidate enumeration
    const threads = getCandidateThreadsVerbose(fwd, CONFIG.RUN.LOOKBACK_DAYS, 5);
    if (!threads.length) return Log.info('[confirmExtruflexPOs] No candidate threads');

    const rows = [];

    threads.forEach(th => {
      let poAtt, poNum, soAtt, soNum;

      // (uses the broadened loop from section 2)
      th.getMessages().forEach(m => {
        const fromRaw  = m.getFrom();
        const fromAddr = (fromRaw.match(/<([^>]+)>/)?.[1] || fromRaw).toLowerCase().trim();

        m.getAttachments().forEach(a => {
          const name = (a.getName() || '').trim();
          if (!/\.pdf$/i.test(name)) return;

          if (!poAtt && fromAddr.includes(CONFIG.ADDRESSES.ME) && RE.PO_NAME.test(name)) {
            poAtt = a; poNum = name.match(RE.PO_NAME)[1];
          }
          if (VENDOR_SENDER_RE.test(fromAddr) && RE.SO_NAME.test(name)) {
            soAtt = a; soNum = name.replace(/\.pdf$/i,'').replace(/^SO[\s_-]?/i,'');
          }
        });
      });

      Log.info(`[confirmExtruflexPOs] thread "${th.getFirstMessageSubject()}" po=${!!poAtt} so=${!!soAtt} poNum=${poNum||''} soNum=${soNum||''}`);
      if (!poAtt || !soAtt) return;

      if (seenInv.has(poNum) || seenConf.has(soNum)) return;

      const soInfo = parseOrderDetails( ocrPdf(soAtt, CONFIG.OCR.LANG) );
      if (!soInfo.orderNumber)   soInfo.orderNumber   = soNum;
      if (!soInfo.invoiceNumber) soInfo.invoiceNumber = poNum;

      const poTxt = ocrPdf(poAtt, CONFIG.OCR.LANG);
      const mTot  = poTxt.match(RE.PO_TOTAL);
      if (!mTot)  return Log.warn(`total not found in ${poAtt.getName()}`);

      rows.push([
        soInfo.invoiceNumber,
        soInfo.orderNumber,
        Number(mTot[1].replace(/,/g,'')),
        soInfo.totalNet     ? Number(soInfo.totalNet)     : '',
        soInfo.totalFreight ? Number(soInfo.totalFreight) : '',
        (function(){
          const d = _normalizeRevDate_(soInfo.estimatedShipDate);
          return (d instanceof Date) ? d : '';
        })()
      ]);

      fwd.removeFromThread(th);
      cnf.addToThread(th);
      th.markRead();
      th.moveToArchive();
      seenInv.add(soInfo.invoiceNumber);
      seenConf.add(soInfo.orderNumber);
    });

    if (rows.length) {
      sh.getRange(sh.getLastRow()+1, 1, rows.length, rows[0].length).setValues(rows);
      Log.info(`Added ${rows.length} row(s)`);
      // Apply formulas to new rows
      _applyExtruflexFormulasSafe_();
    } else {
      Log.info('Nothing new');
    }
  } finally { lock.releaseLock(); }
}

function getCandidateThreadsVerbose(label, lookbackDays, pickLimit) {
  const MS = 24*60*60*1000, cut = Date.now() - lookbackDays*MS;
  const raw = label.getThreads(0, 50); // newest first
  Log.info(`[confirmExtruflexPOs] label has ${raw.length} threads (checking lookback ${lookbackDays}d)`);

  const out = [];
  raw.forEach((th, idx) => {
    const last = th.getLastMessageDate();
    const tooOld = last.getTime() < cut;
    if (tooOld) return;

    // Consider SO PDFs by filename (not MIME alone)
    const hasSO = th.getMessages().some(m =>
      m.getAttachments().some(a => {
        const nm = (a.getName() || '').trim();
        return /\.pdf$/i.test(nm) && RE.SO_NAME.test(nm);
      })
    );

    Log.info(`  • [${idx+1}] "${th.getFirstMessageSubject()}" last=${last} hasSO=${hasSO}`);
    if (hasSO) out.push(th);
  });

  Log.info(`[confirmExtruflexPOs] candidates with SO: ${out.length} (pick ≤ ${pickLimit})`);
  return out.slice(0, pickLimit);
}

function _applyExtruflexFormulasSafe_() {
  try {
    applyExtruflexFormulas();
  } catch (e) {
    Log.err('Error applying formulas: ' + e);
  }
}
/** ---------------------------------
 *  CUSTOMER TRACKING LABEL HELPERS (your two functions, minor tidy)
 * ----------------------------------*/
function buildTrackingQuery(labelName, fromAddress, phrases) {
  const orBlock = '(' + phrases.map(p => `"${p}"`).join(' OR ') + ')';
  return `label:"${labelName}" from:${fromAddress} ("Tracking Number(s):" AND ${orBlock})`;
}

function processTrackingResolved() {
  const LOG = '[processTrackingResolved] ';

  // Phrases kept, but we won’t rely on exact curly quotes
  const phrases = [
    "Here’s the tracking info for your order",
    "You'll find your tracking details below",       // add straight-quote variant
    "You’ll find your tracking details below",
    "Tracking information for your order is below",
    "Here are your shipment tracking details",
    "Below you’ll see the tracking for your order",
    "Here’s where you can track your order",
    "Your tracking details are just below",
    "You can find your order’s tracking info here",
    "Here are the tracking details for your shipment",
    "Order tracking information is listed below"
  ];

  const trackingLabel = GmailU.getOrCreateLabel(CONFIG.LABELS.NEEDS_TRACKING);
  const resolvedLabel = GmailU.getOrCreateLabel(CONFIG.LABELS.RESOLVED);

  // 🧮 1) Show the actual number of threads under the label (what Gmail UI shows)
  const labelThreads = trackingLabel.getThreads(0, 500);  // pull up to 500 recent
  Log.info(`${LOG}label "${CONFIG.LABELS.NEEDS_TRACKING}" has ${labelThreads.length} thread(s)`);

  // 🔎 2) (optional) Still keep your search-based subset for comparison
  const q = buildTrackingQuery(CONFIG.LABELS.NEEDS_TRACKING, CONFIG.ADDRESSES.ME, phrases);
  const matchedBySearch = GmailApp.search(q, 0, 200);
  Log.info(`${LOG}query matched ${matchedBySearch.length} thread(s)`);

  // ✅ 3) Process using the label list (more reliable than Gmail search quirks)
  let changed = 0;

  // tolerant checks
  const meLc = CONFIG.ADDRESSES.ME.toLowerCase();
  const trackingMarkers = [
    /tracking number\(s\)\s*:/i,   // your original marker
    /tracking number\s*:/i,        // common variant
    /tracking:/i,                  // fallback
  ];
  const phraseLc = phrases.map(p => p.toLowerCase());

  labelThreads.forEach(th => {
    const last = GmailU.newestMessage(th);
    if (!last) return;

    // normalize "From" to just the email, lowercased
    const fromRaw = last.getFrom();
    const fromAddr = (fromRaw.match(/<([^>]+)>/)?.[1] || fromRaw).toLowerCase().trim();
    if (!fromAddr.includes(meLc)) return;

    const body = last.getBody() || '';
    const bodyLc = body.toLowerCase();

    // must contain a tracking marker AND (optionally) one of the phrases (case-insensitive)
    const hasTracking = trackingMarkers.some(rx => rx.test(body));
    const hasPhrase   = phraseLc.some(p => bodyLc.includes(p)); // don’t be strict

    if (!hasTracking) return; // marker is the important bit

    try {
      trackingLabel.removeFromThread(th);
      resolvedLabel.addToThread(th);
      changed++;
    } catch (e) {
      Log.err(`${LOG}${e}`);
    }
  });

  Log.info(`${LOG}updated ${changed} thread(s)`);
}

function markThreadsWaitingForTracking() {
  const LOG = '[markThreadsWaitingForTracking] ';
  const customerLabel = GmailApp.getUserLabelByName(CONFIG.LABELS.CUSTOMER);
  if (!customerLabel) return Log.err(`${LOG}Customer label missing`);
  const needsTracking = GmailU.getOrCreateLabel(CONFIG.LABELS.NEEDS_TRACKING);

  const PHRASES = [
    "Because it’s still on the line, tracking isn’t available just yet, but I’ll send the link as soon as it ships.",
    "It’s still in production, so tracking isn’t available yet, but I’ll share the link the moment it leaves our dock.",
    "Since it’s not finished yet, there’s no tracking at the moment, but I’ll send you the link as soon as it’s on its way.",
    "Tracking isn’t live while it’s still on the line, but I’ll send the link the moment your package ships.",
    "Your order is still in the works, so there’s no tracking just yet, but I’ll send it over as soon as it leaves us.",
    "Tracking isn’t available while it’s in production, but I’ll make sure to send the link once it ships out.",
    "Because it’s still being prepared, there’s no tracking right now, but I’ll get you the link as soon as it’s dispatched.",
    "While your order is still on the line, tracking won’t show up yet, but I’ll send the details as soon as it ships.",
    "It’s still in the process, so tracking isn’t ready just yet, but I’ll send you the link the moment it’s on the way.",
    "No tracking is available while it’s still here, but I’ll send the link to you as soon as the package leaves our dock."
  ].map(s => s.toLowerCase());

  const threads = customerLabel.getThreads(0, 25);
  let tagged = 0;
  threads.forEach(th => {
    const last = GmailU.newestMessage(th);
    if (!last || !last.getFrom().toLowerCase().includes(CONFIG.ADDRESSES.ME)) return;
    const bodyLc = last.getBody().toLowerCase();
    if (!PHRASES.some(p => bodyLc.includes(p))) return;
    if (!GmailU.threadHasLabel(th, CONFIG.LABELS.NEEDS_TRACKING)) { needsTracking.addToThread(th); tagged++; }
  });
  Log.info(`${LOG}applied to ${tagged} thread(s)`);
}

function updateExtruflexETDs() { 
  const LOG = '[updateExtruflexETDs] ';
  Log.info(LOG + 'start');

  // 1️⃣ Find the latest OOR email thread and get the Excel attachment
  const OOR_LABEL = CONFIG.LABELS.EX_OOR;
  const oorLabel = GmailApp.getUserLabelByName(OOR_LABEL);
  if (!oorLabel) return Log.err(LOG + `Label "${OOR_LABEL}" not found`);
  const threads = oorLabel.getThreads(0, 1);
  if (!threads.length) return Log.info(LOG + 'No OOR threads found');

  const ATT_RX = /^\d+\s*OOR(?:\s+Panamerica)?(?:\s*\(\d+\))?\.(xlsx|xls)$/i;
  let oorAttachment = null;
  for (const msg of threads[0].getMessages().sort((a, b) => b.getDate() - a.getDate())) {
    for (const att of msg.getAttachments() || []) {
      if (ATT_RX.test((att.getName() || '').trim())) {
        oorAttachment = att;
        break;
      }
    }
    if (oorAttachment) break;
  }
  if (!oorAttachment) {
    // Fallback: if exactly one Excel file is present, use it
    const allExcel = threads[0].getMessages().flatMap(m => m.getAttachments() || [])
                     .filter(a => /\.(xlsx|xls)$/i.test((a.getName() || '').trim()));
    Log.warn(LOG + 'No OOR attachment found by name. Excel files seen: ' +
             (allExcel.map(a => a.getName()).join(', ') || 'none'));
    if (allExcel.length === 1) {
      oorAttachment = allExcel[0];
      Log.info(LOG + 'Using attachment: ' + oorAttachment.getName());
    }
  }
  if (!oorAttachment) return Log.warn(LOG + 'No Excel attachment to process');

  // 2️⃣ Convert the attachment to a Google Sheet and read all values
  let tempFileId;
  let oorData;
  try {
    tempFileId = Drive.Files.insert(
      { title: oorAttachment.getName() + ' (Converted)', mimeType: MimeType.GOOGLE_SHEETS },
      oorAttachment.copyBlob()
    ).id;
    const tss = SpreadsheetApp.openById(tempFileId);
    oorData = tss.getSheets()[0].getDataRange().getValues();
  } finally {
    try { if (tempFileId) Drive.Files.remove(tempFileId); } catch(e) {}
  }
  if (!oorData || oorData.length < 2) return Log.info(LOG + 'OOR sheet is empty or unreadable');

  // 3️⃣ Identify the header row and relevant columns in the OOR data
  const syn = {
    doc:   ['document number','document no','doc number','doc no','so number','sales order number','order number'],
    rev:   ['revised ship date','new ship date','ship date','revised shipping date','expected ship date','shipdate'],
    cref:  ['customer ref','customer reference','cust ref','customerref','invoice'],
    alloc: ['date allocated','allocated','date alloc','allocation date','dateallocated']
  };
  const hdrInfo = _findHeaderRowFlex_(oorData, syn);
  if (hdrInfo.row === -1 || hdrInfo.idx.doc === -1 || hdrInfo.idx.rev === -1) {
    return Log.warn(LOG + 'Could not find expected columns (Document # or Revised Ship Date)');
  }

  // 4️⃣ Build a map of Document# → {revDate, custRef, dateAlloc}, using the latest entry per document
  const oorMap = new Map();
  const allDocs = new Set();
  for (let r = hdrInfo.row + 1; r < oorData.length; r++) {
    const row = oorData[r] || [];
    if (row.join('').trim() === '') continue;  // skip empty rows

    const docKey = String(row[hdrInfo.idx.doc] || '').trim();
    if (!docKey) continue;
    allDocs.add(docKey);

    const rawRev    = row[hdrInfo.idx.rev];
    const custRef   = (hdrInfo.idx.cref  !== -1 ? String(row[hdrInfo.idx.cref] || '').trim() : '');
    const allocVal  = (hdrInfo.idx.alloc !== -1 ? row[hdrInfo.idx.alloc] : '');

    // Parse the Revised Ship Date and Allocation Date
    const revDateObj = _normalizeRevDate_(rawRev, /*allowDelayed*/ true);   // returns Date, 'DELAYED', or null
    const allocDate  = _toDateFlex_(allocVal, /*allowDelayed*/ false);

    // Prepare an entry with parsed dates and original text (for logging)
    let rawRevText = '';
    if (rawRev instanceof Date) {
      rawRevText = rawRev.toDateString();
    } else if (typeof rawRev === 'number') {
      rawRevText = String(rawRev);
    } else if (rawRev) {
      rawRevText = String(rawRev).trim();
    }

    const entry = { revDate: revDateObj, custRef: custRef, dateAlloc: allocDate, rawRev: rawRevText };
    const existing = oorMap.get(docKey);
    if (existing) {
      // Update existing entry if this row is more current
      if (existing.revDate === 'DELAYED' || entry.revDate === 'DELAYED') {
        // If any instance is marked as delayed, keep it delayed
        if (entry.revDate === 'DELAYED' && entry.rawRev) {
          existing.rawRev = entry.rawRev;
        }
        existing.revDate = 'DELAYED';
      } else if (existing.revDate instanceof Date && entry.revDate instanceof Date && entry.revDate > existing.revDate) {
        // Keep the latest (max) date
        existing.revDate = entry.revDate;
        existing.rawRev = entry.rawRev;
      }
      if (!existing.custRef && custRef) existing.custRef = custRef;
      if (!existing.dateAlloc && allocDate) existing.dateAlloc = allocDate;
    } else {
      oorMap.set(docKey, entry);
    }

    // Log any unparseable or delayed dates for debugging
    if (!(revDateObj instanceof Date)) {
      if (rawRevText) {
        Log.warn(LOG + `Doc ${docKey}: Revised Ship Date "${rawRevText}" is not a valid date → parsed as ${revDateObj || 'null'}`);
      } else {
        Log.warn(LOG + `Doc ${docKey}: Revised Ship Date is blank (no date provided)`);
      }
    }
  }

  // Update the "OOR Cache" sheet for the "On OOR?" formula (if used)
  try {
    _writeOORCache_(Array.from(allDocs));
  } catch (e) {
    Log.warn(LOG + 'Could not update OOR Cache: ' + e);
  }

  // 5️⃣ Open the main "Extruflex" sheet and locate key columns
  const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const sh = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
  if (!sh) return Log.err(LOG + `Main sheet "${CONFIG.SHEETS.MAIN_TAB}" not found`);
  const data = sh.getDataRange().getValues();
  if (data.length < 2) return Log.info(LOG + 'No data rows in main sheet');

  const headers = data[0].map(h => String(h || ''));
  const idx = {
    doc: headers.findIndex(h => h.toLowerCase().includes('document')),
    etd: headers.findIndex(h => h.toLowerCase().includes('current') && h.toLowerCase().includes('etd')),
    inv: headers.findIndex(h => h.toLowerCase().includes('invoice')),
    est: headers.findIndex(h => /est.*ship/i.test(h.toLowerCase()))
  };
  if (idx.doc === -1 || idx.etd === -1) {
    return Log.warn(LOG + 'Main sheet is missing "Document #" or "Current ETD" column');
  }

  // 6️⃣ Update ETD for existing rows in the main sheet (preserve if OOR has no date)
  let updatedCount = 0, preservedCount = 0;
  for (let i = 1; i < data.length; i++) {
    const docKey = String(data[i][idx.doc] || '').trim();
    if (!docKey || !oorMap.has(docKey)) continue;

    const entry = oorMap.get(docKey);

    // Old ETD (for logging only)
    const oldETDVal = data[i][idx.etd];
    const oldETDText =
      (oldETDVal instanceof Date) ? oldETDVal.toDateString() :
      (oldETDVal ? String(oldETDVal).trim() : '(blank)');

    if (entry.revDate instanceof Date) {
      // ✅ Only update when OOR provides a real date
      sh.getRange(i + 1, idx.etd + 1).setValue(entry.revDate);
      Log.info(LOG + `Doc ${docKey}: Current ETD updated from "${oldETDText}" to ${entry.revDate.toDateString()}`);
      updatedCount++;
    } else {
      // 🚫 No date in OOR → keep whatever is in the sheet
      Log.info(LOG + `Doc ${docKey}: No valid Revised Ship Date in OOR ("${entry.rawRev || 'none'}"); preserved existing ETD "${oldETDText}"`);
      preservedCount++;
    }

    // Still OK to update these if present
    if (idx.est !== -1 && entry.dateAlloc instanceof Date) {
      sh.getRange(i + 1, idx.est + 1).setValue(entry.dateAlloc);
    }
    if (idx.inv !== -1 && !String(data[i][idx.inv] || '').trim()) {
      const invNum = (entry.custRef || '').replace(/^2363-/, '');
      if (invNum) sh.getRange(i + 1, idx.inv + 1).setValue(invNum);
    }

    oorMap.delete(docKey);
  }
  Log.info(LOG + `Updated Current ETD for ${updatedCount} row(s); preserved ${preservedCount} row(s) without OOR date`);


  // 7️⃣ Append any new orders from OOR that weren't already in the main sheet
  let addedCount = 0;
  if (oorMap.size > 0) {
    const newRows = [];
    for (const [docKey, entry] of oorMap) {
      const newRow = new Array(headers.length).fill('');
      // Set known fields: Invoice, Document, Estimated Ship, Current ETD
      if (idx.inv !== -1) {
        newRow[idx.inv] = (entry.custRef || '').replace(/^2363-/, '');
      }
      newRow[idx.doc] = docKey;
      if (idx.est !== -1 && entry.dateAlloc instanceof Date) {
        newRow[idx.est] = entry.dateAlloc;
      }
      newRow[idx.etd] = (entry.revDate instanceof Date ? entry.revDate : '');
      newRows.push(newRow);
      addedCount++;

      // Log details for the new row
      if (entry.revDate instanceof Date) {
        Log.info(LOG + `Added new order ${docKey} with ETD ${entry.revDate.toDateString()}`);
      } else {
        Log.warn(LOG + `Added new order ${docKey}: no valid ETD in OOR (found "${entry.rawRev || 'none'}"), used fallback ${fallbackDate.toDateString()}`);
      }
    }
    if (newRows.length) {
      sh.getRange(sh.getLastRow() + 1, 1, newRows.length, headers.length).setValues(newRows);
    }
  }
  Log.info(LOG + `Added ${addedCount} new order(s) to the sheet`);

  // 8️⃣ Move any fully shipped orders from the "OOR" sheet to the "OOR Archive" sheet
  (function archiveShippedFromOOR() {
    const oorSheet = ss.getSheetByName('OOR');
    const archiveSheet = ss.getSheetByName('OOR Archive') || ss.insertSheet('OOR Archive');
    if (!oorSheet) return;

    const oorVals = oorSheet.getDataRange().getValues();
    if (oorVals.length < 2) return;

    const headers = oorVals[0];
    const iDoc = headers.indexOf('Document Number');
    const iETD = headers.indexOf('ETD');
    if (iDoc === -1 || iETD === -1) return;

    // Build shipped set from Tracking Cache (preferred) → fallback Tracking Log
    const norm = s => String(s||'').replace(/\s+/g,' ').trim().toLowerCase();
    let shippedDocs = new Set();
    const cache = ss.getSheetByName('Tracking Cache');
    if (cache && cache.getLastRow() >= 2) {
      const vals = cache.getRange(2,1,cache.getLastRow()-1,1).getValues().flat();
      shippedDocs = new Set(vals.map(v => String(v||'').trim()).filter(Boolean));
    } else {
      const trackingSheet = ss.getSheetByName('Tracking Log');
      if (trackingSheet) {
        const tVals = trackingSheet.getDataRange().getValues();
        if (tVals.length >= 2) {
          const tH = tVals[0].map(norm);
          const tDoc = tH.findIndex(h => ['document number','document#','document #','doc number','so number','order number'].includes(h));
          if (tDoc !== -1) {
            shippedDocs = new Set(tVals.slice(1).map(r => String(r[tDoc]||'').trim()).filter(Boolean));
          }
        }
      }
    }

    const today = new Date();
    const rowsToArchive = [];
    for (let r = 1; r < oorVals.length; r++) {
      const doc = String(oorVals[r][iDoc] || '').trim();
      if (!doc || !shippedDocs.has(doc)) continue;
      const etdVal = oorVals[r][iETD];
      if (etdVal instanceof Date && (today - etdVal) / 86400000 >= 3) {
        rowsToArchive.push(r + 1);
      }
    }
    if (!rowsToArchive.length) return;
    if (archiveSheet.getLastRow() === 0) {
      archiveSheet.appendRow(headers);
      archiveSheet.setFrozenRows(1);
    }
    rowsToArchive.sort((a, b) => b - a);
    for (const r of rowsToArchive) {
      const values = oorSheet.getRange(r, 1, 1, headers.length).getValues()[0];
      archiveSheet.appendRow(values);
      oorSheet.deleteRow(r);
    }
    Log.info('[updateExtruflexETDs] Archived ' + rowsToArchive.length + ' row(s) from "OOR".');
  })();


  // 9️⃣ Remove old completed orders from the main sheet (those not in OOR and ETD > ~4 days old)
  (function pruneOldCompleted() {
    // First: delete rows where "Cancelled"/"Canceled" is TRUE (header-insensitive)
    const headersNorm = headers.map(h => String(h || '').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim());
    const iCancelled = headersNorm.findIndex(h => h === 'cancelled' || h === 'canceled');
    if (iCancelled !== -1) {
      for (let r = sh.getLastRow(); r >= 2; r--) {
        if (sh.getRange(r, iCancelled + 1).getValue() === true) {
          sh.deleteRow(r);
        }
      }
    }

    // Then: existing “old completed” pruning (unchanged) …
    const today = new Date();
    const cutoff = new Date(today.getTime() - 4 * 24*60*60*1000);  // 4 days ago
    for (let r = sh.getLastRow(); r >= 2; r--) {
      const doc = String(sh.getRange(r, idx.doc + 1).getValue() || '').trim();
      if (!doc || allDocs.has(doc)) continue;  // skip if still in current OOR list
      const etdVal = sh.getRange(r, idx.etd + 1).getValue();
      let outdated = false;
      if (etdVal instanceof Date) {
        outdated = etdVal.getTime() < cutoff.getTime();
      } else if (typeof etdVal === 'string') {
        const s = etdVal.trim();
        if (!s || /week|delay/i.test(s)) {
          outdated = false;  // ignore textual "delayed" flags
        } else {
          const d = _toDateFlex_(s, false);
          if (d instanceof Date) outdated = d.getTime() < cutoff.getTime();
        }
      }
      if (outdated) sh.deleteRow(r);
    }
  })();

  try { _rebuildTrackingCache_(); } catch (e) {
    Log.warn('[updateExtruflexETDs] Could not refresh Tracking Cache: ' + e);
  }

  // 🔟 Refresh totals/formulas and conclude
  if (SheetU?.refreshExtruflexTable) SheetU.refreshExtruflexTable();
  applyExtruflexFormulas();
  if (typeof _archiveOORRowsUsingTracking_ === 'function') {
    _archiveOORRowsUsingTracking_();
  }
  Log.info(LOG + 'done');
  (function enforceETDFormat(){
    try {
      const last = sh.getLastRow();
      if (last >= 2) {
        sh.getRange(2, idx.etd + 1, last - 1, 1).setNumberFormat('mmm d, yyyy');
      }
    } catch (e) {
      if (String(e).includes('typed column')) {
        Log.warn(LOG + 'ETD is a typed column; skipping number-format normalization.');
      } else {
        throw e;
      }
    }
  })();
}

/* ----------------- Helpers ----------------- */
/** Month token → number (supports "sept") */
function _monTokenToNum_(tok) {
  const t = String(tok || '').trim().toLowerCase();
  const map = { jan:1, feb:2, mar:3, apr:4, may:5, jun:6, jul:7, aug:8, sep:9, sept:9, oct:10, nov:11, dec:12 };
  return map[t] || null;
}
function _daysInMonth_(y, m) { return new Date(y, m, 0).getDate(); }

/** Excel serial → Date (Apps Script/Sheets use 1899-12-31 base) */
function _excelSerialToDate_(n) {
  const ms = Math.round((Number(n) - 25569) * 86400000);
  const d  = new Date(ms);
  return isNaN(d) ? null : d;
}

/**
 * Compose a Date for month/day with no explicit year:
 * - Use CURRENT YEAR (or next year for Dec→Jan crossover).
 */
function _composeSameYear_(m, d, today) {
  const now   = today || new Date();
  const curM  = now.getMonth() + 1;
  const year  = (curM === 12 && m === 1) ? (now.getFullYear() + 1) : now.getFullYear();
  const day   = Math.min(Math.max(1, d|0), _daysInMonth_(year, m));
  return new Date(year, m - 1, day);
}

/**
 * STRICT normalizer for Revised Ship Date:
 * 1) Date object → return that exact date (strip time).
 * 2) Plausible Excel serial (>= 40000 and <= 80000) → exact date.
 * 3) Full dd/mm/yyyy (or mm/dd/yyyy) → exact date preserving year.
 * 4) dd/mm/##### “glitch” → treat ##### as junk; keep dd/mm with current-year policy.
 * 5) "27 Aug" / "Aug 27" → current-year policy.
 * 6) Otherwise try native Date; else null.
 * Also treats “delay/pending/week” as DELAYED.
 */
function _normalizeRevDate_(raw) {
  if (raw == null || raw === '') return null;

  const sMaybe = (typeof raw === 'string') ? raw.trim() : '';
  if (sMaybe && /week|delay|pend/i.test(sMaybe)) return 'DELAYED';

  if (raw instanceof Date && !isNaN(raw)) {
    return new Date(raw.getFullYear(), raw.getMonth(), raw.getDate());
  }

  // Excel serial (plausible range only)
  if (typeof raw === 'number' && isFinite(raw)) {
    // Accept 8-digit YYYYMMDD numbers as well
    if (raw >= 19000101 && raw <= 21991231 && String(Math.floor(raw)).length === 8) {
      const s = String(Math.floor(raw));
      const y = +s.slice(0,4), m = +s.slice(4,6), d = +s.slice(6,8);
      const dt = new Date(y, m-1, d);
      return isNaN(dt) ? null : new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
    }
    if (raw >= 40000 && raw <= 80000) {
      const ms = Math.round((raw - 25569) * 86400000);
      const d  = new Date(ms);
      return isNaN(d) ? null : new Date(d.getFullYear(), d.getMonth(), d.getDate());
    }
    return null;
  }

  const s = sMaybe;
  if (!s) return null;

  // dd/mm/yyyy or mm/dd/yyyy
  let m = s.match(/^(\d{1,2})[\/\-\.\s](\d{1,2})[\/\-\.\s](\d{2,4})\b/);
  if (m) {
    let a = +m[1], b = +m[2], y = +m[3];
    if (y < 100) y += (y >= 70 ? 1900 : 2000);
    let dd, mm;
    if (a > 12 && b <= 12) { dd = a; mm = b; } else if (b > 12 && a <= 12) { dd = b; mm = a; } else { dd = a; mm = b; }
    return new Date(y, mm - 1, dd);
  }

  // >>> ADD THIS: strict YYYYMMDD text <<<
  m = s.match(/^\d{8}$/);
  if (m) {
    const y = +s.slice(0,4), mo = +s.slice(4,6), d = +s.slice(6,8);
    const dt = new Date(y, mo-1, d);
    return isNaN(dt) ? null : dt;
  }

  // dd/mm/##### glitch → current-year policy
  m = s.match(/^(\d{1,2})[\/\-\.\s](\d{1,2})[\/\-\.\s](\d{5})\b/);
  if (m) {
    const dd = +m[1], mm = +m[2];
    return _composeSameYear_(mm, dd, new Date());
  }

  // e.g., "27 Aug", "Aug 27"
  m = s.match(/^(\d{1,2})\s+([A-Za-z]{3,})\b/);
  if (m) { const mo = _monTokenToNum_(m[2]); if (mo) return _composeSameYear_(mo, +m[1], new Date()); }
  m = s.match(/^([A-Za-z]{3,})\s+(\d{1,2})\b/);
  if (m) { const mo = _monTokenToNum_(m[1]); if (mo) return _composeSameYear_(mo, +m[2], new Date()); }

  const d = new Date(s);
  return isNaN(d) ? null : new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

/**
 * General date parser used elsewhere (e.g., Allocation Date).
 * Now guarded so small integers aren’t misread as serials.
 * If allowDelayed === true, returns 'DELAYED' for “delay/week/pending”.
 */
function _toDateFlex_(v, allowDelayed) {
  if (v == null || v === '') return null;
  if (v instanceof Date && !isNaN(v)) return new Date(v.getFullYear(), v.getMonth(), v.getDate());

  if (typeof v === 'number' && isFinite(v)) {
    if (v >= 19000101 && v <= 21991231 && String(Math.floor(v)).length === 8) {
      const s = String(Math.floor(v));
      const y = +s.slice(0,4), m = +s.slice(4,6), d = +s.slice(6,8);
      const dt = new Date(y, m-1, d);
      return isNaN(dt) ? null : new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
    }
    if (v >= 40000 && v <= 80000) {
      const ms = Math.round((v - 25569) * 86400000);
      const d  = new Date(ms);
      return isNaN(d) ? null : new Date(d.getFullYear(), d.getMonth(), d.getDate());
    }
    return null;
  }

  const s = String(v).trim();
  if (!s) return null;
  if (allowDelayed && /week|delay|pend/i.test(s)) return 'DELAYED';

  // dd/mm/yyyy or mm/dd/yyyy
  let m = s.match(/^(\d{1,2})[\/\-\.\s](\d{1,2})[\/\-\.\s](\d{2,4})\b/);
  if (m) {
    let a = +m[1], b = +m[2], y = +m[3];
    if (y < 100) y += (y >= 70 ? 1900 : 2000);
    let dd, mm;
    if (a > 12 && b <= 12) { dd = a; mm = b; } else if (b > 12 && a <= 12) { dd = b; mm = a; } else { dd = a; mm = b; }
    return new Date(y, mm - 1, dd);
  }

  // >>> ADD THIS: strict YYYYMMDD text <<<
  if (/^\d{8}$/.test(s)) {
    const y = +s.slice(0,4), mo = +s.slice(4,6), d = +s.slice(6,8);
    const dt = new Date(y, mo-1, d);
    return isNaN(dt) ? null : dt;
  }

  // dd/mm/##### glitch → current year policy
  m = s.match(/^(\d{1,2})[\/\-\.\s](\d{1,2})[\/\-\.\s](\d{5})\b/);
  if (m) {
    const dd = +m[1], mm = +m[2];
    return _composeSameYear_(mm, dd, new Date());
  }

  const d = new Date(s);
  return isNaN(d) ? null : new Date(d.getFullYear(), d.getMonth(), d.getDate());
}

function _fallbackSameYearDate_() {
  const now = new Date();
  const curM = now.getMonth() + 1;
  const nextM = (curM === 12 ? 1 : curM + 1);
  const year = (curM === 12 ? now.getFullYear() + 1 : now.getFullYear());
  return new Date(year, nextM - 1, 1); // 1st day of next month
}

/**
 * Find header row by scanning the top N rows and matching synonyms.
 * Prefers "Revised Ship Date" (and variants) over "Ship Date".
 * Returns { row, idx: {doc, rev, cref, alloc} } with 0-based column indices.
 */
function _findHeaderRowFlex_(data, syn) {
  const maxScan = Math.min(15, data.length);

  const norm = v => String(v == null ? '' : v)
    .replace(/\u00A0/g,' ')
    .replace(/[\u200B-\u200D]/g,'')
    .replace(/\s+/g,' ')
    .trim()
    .toLowerCase();

  // exact-match search honoring token priority (tokens are already normalized)
  const firstIdxByPriority = (row, tokens) => {
    const rowN = row.map(norm);
    for (const tok of tokens) {
      const j = rowN.indexOf(tok);
      if (j !== -1) return j;
    }
    return -1;
  };

  // legacy fallback: earliest column that matches ANY token (left→right)
  const firstIdxAny = (row, tokens) => {
    const rowN = row.map(norm);
    for (let j = 0; j < rowN.length; j++) {
      if (tokens.includes(rowN[j])) return j;
    }
    return -1;
  };

  // Build prioritized lists
  const DOC_LIST   = (syn.doc   || []).map(s => s.toLowerCase());
  const CREF_LIST  = (syn.cref  || []).map(s => s.toLowerCase());
  const ALLOC_LIST = (syn.alloc || []).map(s => s.toLowerCase());

  // For "rev", split into STRICT (preferred) vs LOOSE (fallback)
  const REV_STRICT = [
    'revised ship date',
    'revised shipping date',
    'new ship date',
    'expected ship date',
    'revised etd',
    'new etd'
  ].map(s => s.toLowerCase());

  // Keep "ship date" only as a fallback
  const REV_LOOSE  = [
    'ship date',
    'shipdate'
  ];

  let best = { row: -1, score: -1, idx: { doc:-1, rev:-1, cref:-1, alloc:-1 } };

  for (let r = 0; r < maxScan; r++) {
    const row = data[r] || [];

    const doc   = (DOC_LIST.length   ? firstIdxByPriority(row, DOC_LIST)     : -1);
    const cref  = (CREF_LIST.length  ? firstIdxByPriority(row, CREF_LIST)    : -1);
    const alloc = (ALLOC_LIST.length ? firstIdxByPriority(row, ALLOC_LIST)   : -1);

    // revised-first, then ship-date fallback
    let rev = firstIdxByPriority(row, REV_STRICT);
    if (rev === -1) rev = firstIdxByPriority(row, REV_LOOSE);

    // if caller provided extra rev synonyms, use them ONLY if we still have none
    if (rev === -1 && Array.isArray(syn.rev) && syn.rev.length) {
      rev = firstIdxAny(row, syn.rev.map(s => s.toLowerCase()));
    }

    const score = (doc !== -1) + (rev !== -1) + (cref !== -1) + (alloc !== -1);
    if (score > best.score) best = { row: r, score, idx: { doc, rev, cref, alloc } };
  }

  return best;
}


function _parseDMY_(s) {
  const m = String(s).trim().match(/^(\d{1,2})[\/\-\.\s](\d{1,2})[\/\-\.\s](\d{2,5})(?:\b.*)?$/);
  if (!m) return null;
  const d = +m[1], mo = +m[2], yRaw = +m[3];
  // "Year" looks like an Excel serial → convert via serial.
  if (yRaw >= 40000) {
    const ms = Math.round((yRaw - 25569) * 86400000);
    const dt = new Date(ms);
    return isNaN(dt) ? null : dt;
  }
  let y = yRaw;
  if (y < 100) y += (y >= 70 ? 1900 : 2000);
  const dt = new Date(y, mo - 1, d);
  return isNaN(dt) ? null : dt;
}

// ---- Public entry: run this to (re)apply all formulas on the "Extruflex" tab
function applyExtruflexFormulas() {
  const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const sh = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
  if (!sh) throw new Error(`Sheet "${CONFIG.SHEETS.MAIN_TAB}" not found`);
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;

  const headerMap = _getHeaderMap_(sh);
  const col = (h) => _colByHeader_(headerMap, sh, h, /*createIfMissing*/ false);
  const colEnsure = (h) => _colByHeader_(headerMap, sh, h, /*createIfMissing*/ true);
  const A1 = (c)=>_colLetter_(c);

  // These *must* exist (created by your pipeline earlier)
  const cDoc = col('document #');
  const cS   = col('s total (usd)');
  const cE   = col('e total (usd)');
  const cFr  = col('freight (usd)');
  const cETD = col('current  etd');

  if ([cDoc,cS,cE,cFr,cETD].some(x => x <= 0)) {
    throw new Error('Missing one of required headers: Document #, S Total (USD), E Total (USD), Freight (USD), Current  ETD');
  }

  // Ensure these target columns exist (create if needed)
  const cProdCost = colEnsure('product cost (usd)');
  const cDiscPct  = colEnsure('product discrepancy (%)');
  const cDiscUsd  = colEnsure('total discrepancy (usd)');
  const cOnOOR    = colEnsure('on oor?');
  const cHasTrack = colEnsure('has tracking?');
  const cRemove   = colEnsure('remove?');

  // --- Same-row arithmetic (R1C1)
  _fillDownR1C1_(sh, cProdCost, `=IF(LEN(RC${cE}), IFERROR(RC${cE}-RC${cFr}, ""), "")`);
  _fillDownR1C1_(sh, cDiscPct,  `=IF(OR(LEN(RC${cS})=0,LEN(RC${cE})=0), "", IFERROR((RC${cE}-RC${cS})/RC${cS}, ""))`);
  _fillDownR1C1_(sh, cDiscUsd,  `=IF(OR(LEN(RC${cS})=0,LEN(RC${cE})=0), "", IFERROR(RC${cE}-RC${cS}, ""))`);

  // --- Row-relative lookups (NO CACHES)

  // 1) On OOR?  → search the live "OOR" tab by Document Number (fallback: "OOR Archive")
  (function setOnOOR(){
    function findDocCol(sheet) {
      if (!sheet || sheet.getLastRow() < 1) return -1;
      const H = sheet.getRange(1,1,1,sheet.getLastColumn()).getValues()[0]
        .map(h => String(h||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim());
      const DOC_TOKENS = [
        'document number','document#','document #','doc number','doc no',
        'so number','sales order number','order number'
      ];
      return H.findIndex(h => DOC_TOKENS.includes(h)) + 1; // 1-based, or 0 if not found
    }

    const oor = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID).getSheetByName('OOR');
    const arc = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID).getSheetByName('OOR Archive');

    let refRange = null;
    let cDocOOR = findDocCol(oor);
    if (cDocOOR > 0) {
      refRange = `'OOR'!C${cDocOOR}`;              // R1C1: whole column by index
    } else {
      cDocOOR = findDocCol(arc);
      if (cDocOOR > 0) refRange = `'OOR Archive'!C${cDocOOR}`;
    }

    const fOnOOR = refRange
      ? `=IFERROR(COUNTIF(${refRange}, RC${cDoc})>0, FALSE)`
      : `=FALSE`; // if neither sheet/column found, default to FALSE

    _fillDownR1C1_(sh, cOnOOR, fOnOOR);
  })();

  // 2) Has Tracking? → compare "2363-" + Invoice against "Tracking Log"!B:B (BP Reference No.)
  (function setHasTracking(){
    // find the Invoice column on the current sheet
    const headerRow = sh.getRange(1,1,1, sh.getLastColumn()).getValues()[0];
    const Hn = headerRow.map(h => String(h||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim());
    const cInv = Hn.findIndex(h => h.includes('invoice')) + 1;

    const fHasTrack = (cInv > 0)
      ? `=IFERROR(
          IF(LEN(TRIM(RC${cInv}))=0,
              FALSE,
              COUNTIF('Tracking Log'!C2,
                IF(LEFT(TRIM(RC${cInv}),5)="2363-",
                  TRIM(RC${cInv}),
                  "2363-" & TRIM(RC${cInv})
                )
              )>0
          ),
        FALSE)`
      : `=FALSE`;  // if no invoice column, can’t match; default FALSE

    _fillDownR1C1_(sh, cHasTrack, fHasTrack);
  })();
  
  // Keep "Remove?" as A1 for readability (it references other computed columns)
  const etdA1   = A1(cETD);
  const onOORA1 = A1(cOnOOR);
  const hasTrA1 = A1(cHasTrack);

  const fRem = `=AND(
    NOT(INDEX(${onOORA1}:${onOORA1}, ROW())),
    INDEX(${hasTrA1}:${hasTrA1}, ROW()),
    ISNUMBER(INDEX(${etdA1}:${etdA1}, ROW())),
    TODAY() - INDEX(${etdA1}:${etdA1}, ROW()) >= 3
  )`;
  _fillDownA1_(sh, cRemove, fRem);
}

// ---- Small reusable helper: apply one formula to a column by header
function applyFormulaToColumn(sheetName, headerName, formulaA1_or_R1C1, useR1C1) {
  const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const sh = ss.getSheetByName(sheetName);
  if (!sh) throw new Error(`Sheet "${sheetName}" not found`);
  const headerMap = _getHeaderMap_(sh);
  const col = _colByHeader_(headerMap, sh, headerName, /*createIfMissing*/ true);
  if (useR1C1) _fillDownR1C1_(sh, col, formulaA1_or_R1C1);
  else         _fillDownA1_(sh, col, formulaA1_or_R1C1);
}

/* ---------------- internals ---------------- */

function _fillDownR1C1_(sh, colIndex, r1c1Formula) {
  const lastRow = Math.max(sh.getLastRow(), 2);
  if (lastRow < 2) return;
  const rows = lastRow - 1;
  sh.getRange(2, colIndex, rows, 1).setFormulaR1C1(r1c1Formula);
}

function _fillDownA1_(sh, colIndex, a1Formula) {
  const lastRow = Math.max(sh.getLastRow(), 2);
  if (lastRow < 2) return;
  const rows = lastRow - 1;
  // put same formula in entire range; it uses ROW() to self-reference
  sh.getRange(2, colIndex, rows, 1).setFormula(a1Formula);
}


function _getHeaderMap_(sh) {
  const n = sh.getLastColumn();
  if (n === 0) return {};
  const raw = sh.getRange(1, 1, 1, n).getValues()[0];
  const map = {};
  raw.forEach((h, i) => { map[_canonHeader_(h)] = i + 1; });
  return map;
}

function _colByHeader_(headerMap, sh, headerName, createIfMissing) {
  const key = _canonHeader_(headerName);
  let idx = headerMap[key] || -1;
  if (idx > 0) return idx;
  if (!createIfMissing) return -1;
  // create at end
  const newCol = sh.getLastColumn() + 1;
  sh.insertColumnAfter(sh.getLastColumn());
  sh.getRange(1, newCol).setValue(headerName);
  headerMap[key] = newCol;
  return newCol;
}

function _colLetter_(colIndex) {
  let c = colIndex, s = '';
  while (c > 0) { const m = (c - 1) % 26; s = String.fromCharCode(65 + m) + s; c = (c - m - 1) / 26; }
  return s;
}

/* ---- OPTIONAL: keep an OOR cache for the "On OOR?" formula ----
   Call this at the end of updateExtruflexETDs(), passing the Set of doc numbers (allDocs).
   Example in updateExtruflexETDs():
     _writeOORCache_(Array.from(allDocs));
*/
function _writeOORCache_(docKeys) {
  const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const sh = ss.getSheetByName('OOR Cache') || ss.insertSheet('OOR Cache');
  sh.clearContents();
  sh.getRange(1,1).setValue('Document #');
  if (docKeys && docKeys.length) {
    const vals = docKeys.map(d => [d]);
    sh.getRange(2,1,vals.length,1).setValues(vals);
  }
}

/* ---- OPTIONAL: prune rows using the Remove? flag (col header "Remove?") ---- */
function pruneByRemoveFlag() {
  const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const sh = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
  if (!sh) throw new Error(`Sheet "${CONFIG.SHEETS.MAIN_TAB}" not found`);
  const headerMap = _getHeaderMap_(sh);
  const cRemove = _colByHeader_(headerMap, sh, 'Remove?', false);
  if (cRemove <= 0) return;
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return;
  const vals = sh.getRange(2, cRemove, lastRow-1, 1).getValues().flat();
  for (let i = vals.length - 1; i >= 0; i--) {
    if (vals[i] === true) sh.deleteRow(i + 2);
  }
}

/**
 * Append ALL existing data rows (2..last) from `src` to "Tracking Log",
 * then clear those rows from `src`. No date gating.
 */
function _archiveAllRowsToLog_(ss, src) {
  const lastRow = src.getLastRow();
  const lastCol = Math.max(src.getLastColumn(), 8); // ensure at least 8 cols
  if (lastRow < 2) return; // no data rows

  const data = src.getRange(2, 1, lastRow - 1, lastCol).getValues();
  // Skip if all rows are empty
  const nonEmpty = data.filter(r => r.join('').trim() !== '');
  if (!nonEmpty.length) {
    // clear anyway in case there are blank rows
    src.getRange(2, 1, lastRow - 1, lastCol).clearContent();
    return;
  }

  const log = ss.getSheetByName('Tracking Log') || ss.insertSheet('Tracking Log');
  const start = log.getLastRow() + 1;
  log.getRange(start, 1, nonEmpty.length, lastCol).setValues(nonEmpty);

  // Clear all data rows from source (one shot)
  src.getRange(2, 1, lastRow - 1, src.getLastColumn()).clearContent();
}

function _archiveOORRowsUsingTracking_(graceDays) {
  const LOG = '[archiveOOR] ';
  const ss  = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);

  const src = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
  if (!src) { Log.warn(`${LOG}No source sheet "${CONFIG.SHEETS.MAIN_TAB}"`); return; }

  const archive = ss.getSheetByName('OOR Archive') || ss.insertSheet('OOR Archive');

  const srcVals = src.getDataRange().getValues();
  if (srcVals.length < 2) return;

  const norm = s => String(s||'').replace(/\s+/g,' ').trim().toLowerCase();
  const hdr = srcVals[0];
  if (archive.getLastRow() === 0) { archive.appendRow(hdr); archive.setFrozenRows(1); }
  const H = hdr.map(norm);

  // Columns in MAIN_TAB
  const docIdx      = H.findIndex(h => ['document#','document #','document number','doc number','so number','order number'].includes(h));
  const etdIdx      = H.findIndex(h => ['current etd','current  etd','etd','revised ship date','new ship date','ship date','expected ship date'].includes(h));
  const hasTrackIdx = H.findIndex(h => ['has tracking?','has tracking'].includes(h));

  if (docIdx === -1) { Log.warn(`${LOG}Document column not found in "${CONFIG.SHEETS.MAIN_TAB}"`); return; }
  if (etdIdx === -1 && Number.isFinite(graceDays) && graceDays > 0) {
    Log.warn(`${LOG}ETD/Ship column not found (needed when graceDays > 0)`); return;
  }

  // --- shipped set FROM Tracking Cache (preferred) → fallback to Tracking Log
  let shippedDocs = new Set();
  const cache = ss.getSheetByName('Tracking Cache');
  if (cache && cache.getLastRow() >= 2) {
    const vals = cache.getRange(2, 1, cache.getLastRow() - 1, 1).getValues().flat();
    shippedDocs = new Set(vals.map(v => String(v || '').trim()).filter(Boolean));
  } else {
    const log = ss.getSheetByName('Tracking Log');
    if (log && log.getLastRow() >= 2) {
      const tH = log.getRange(1,1,1,log.getLastColumn()).getValues()[0].map(norm);
      const tDoc = tH.findIndex(h => ['document number','document#','document #','doc number','so number','order number'].includes(h));
      if (tDoc !== -1) {
        const tVals = log.getRange(2, tDoc+1, log.getLastRow()-1, 1).getValues().flat();
        shippedDocs = new Set(tVals.map(v => String(v || '').trim()).filter(Boolean));
      }
    }
  }

  const today = new Date();
  const GRACE_DAYS = Number.isFinite(graceDays) ? Math.max(0, Math.floor(graceDays)) : 0;

  const toMove = [];
  for (let r = 1; r < srcVals.length; r++) {
    const row = srcVals[r];
    const doc = String(row[docIdx] || '').trim();
    if (!doc) continue;

    // Prefer the "Has tracking?" column (already driven by Tracking Cache); else fallback set
    const hasTracking = (hasTrackIdx !== -1) ? (row[hasTrackIdx] === true) : shippedDocs.has(doc);
    if (!hasTracking) continue;

    let ageOK = true;
    if (GRACE_DAYS > 0) {
      const etd = row[etdIdx];
      ageOK = (etd instanceof Date) && ((today - etd) / 86400000) >= GRACE_DAYS;
    }
    if (ageOK) toMove.push(r + 1);
  }

  if (!toMove.length) return;
  toMove.sort((a, b) => b - a);
  for (const r of toMove) {
    const vals = src.getRange(r, 1, 1, hdr.length).getValues()[0];
    archive.appendRow(vals);
    src.deleteRow(r);
  }
  Log.info(`${LOG}Archived ${toMove.length} row(s) from "${CONFIG.SHEETS.MAIN_TAB}" to "OOR Archive".`);
}

function repairExtruflexCurrentETDs() {
  const LOG = '[repairExtruflexCurrentETDs] ';
  const ss  = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const sh  = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
  if (!sh) { Log.err(LOG + 'Main tab not found'); return; }
  if (sh.getLastRow() < 2) { Log.info(LOG + 'No data'); return; }

  // --- 1) Find latest OOR Excel attachment (same rule as updater)
  const oorLabel = GmailApp.getUserLabelByName(CONFIG.LABELS.EX_OOR);
  if (!oorLabel) { Log.err(LOG + `Label "${CONFIG.LABELS.EX_OOR}" not found`); return; }
  const threads = oorLabel.getThreads(0, 1);
  if (!threads.length) { Log.info(LOG + 'No OOR threads found'); return; }

  const ATT_RX = /^\d+\s*OOR(?:\s+Panamerica)?(?:\s*\(\d+\))?\.(xlsx|xls)$/i;
  let oorAttachment = null;
  for (const msg of threads[0].getMessages().sort((a,b)=>b.getDate()-a.getDate())) {
    for (const att of msg.getAttachments() || []) {
      if (ATT_RX.test((att.getName() || '').trim())) { oorAttachment = att; break; }
    }
    if (oorAttachment) break;
  }
  if (!oorAttachment) {
    const allExcel = threads[0].getMessages().flatMap(m => m.getAttachments() || [])
                     .filter(a => /\.(xlsx|xls)$/i.test((a.getName() || '').trim()));
    if (allExcel.length === 1) {
      oorAttachment = allExcel[0];
      Log.info(LOG + 'Fallback using attachment: ' + oorAttachment.getName());
    } else {
      Log.warn(LOG + 'No OOR attachment found'); return;
    }
  }

  // --- 2) Convert to temp Google Sheet and read
  let tempFileId, data;
  try {
    tempFileId = Drive.Files.insert(
      { title: oorAttachment.getName() + ' (Converted)', mimeType: MimeType.GOOGLE_SHEETS },
      oorAttachment.copyBlob()
    ).id;
    const tss = SpreadsheetApp.openById(tempFileId);
    data = tss.getSheets()[0].getDataRange().getValues();
  } finally {
    try { if (tempFileId) Drive.Files.remove(tempFileId); } catch(e) {}
  }
  if (!data || data.length < 2) { Log.info(LOG + 'OOR sheet empty or unreadable'); return; }

  // --- 3) Find columns (Document #, Revised Ship Date)
  const syn = {
    doc:   ['document number','document no','doc number','doc no','so number','sales order number','order number'],
    rev:   ['revised ship date','new ship date','ship date','revised shipping date','expected ship date','shipdate']
  };
  const hdrInfo = _findHeaderRowFlex_(data, syn);
  if (hdrInfo.row === -1 || hdrInfo.idx.doc === -1 || hdrInfo.idx.rev === -1) {
    Log.warn(LOG + 'Could not find expected columns (Document # or Revised Ship Date)'); return;
  }

  // --- 4) Build map doc → raw revised date (use latest entry per doc)
  const byDoc = new Map();
  for (let r = hdrInfo.row + 1; r < data.length; r++) {
    const row = data[r] || [];
    if (row.join('').trim() === '') continue;
    const docKey = String(row[hdrInfo.idx.doc] || '').trim();
    if (!docKey) continue;
    const rawRev = row[hdrInfo.idx.rev];

    const existing = byDoc.get(docKey);
    // Keep the latest-looking (if both are dates, keep the max; else prefer a Date over non-date)
    if (!existing) {
      byDoc.set(docKey, rawRev);
    } else {
      const a = existing instanceof Date ? +existing : NaN;
      const b = rawRev   instanceof Date ? +rawRev   : NaN;
      if (!isNaN(b) && (isNaN(a) || b > a)) byDoc.set(docKey, rawRev);
    }
  }
  if (!byDoc.size) { Log.info(LOG + 'No OOR rows with Document + Revised Ship Date'); return; }

  // --- 5) Locate columns in main sheet
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const norm = s => String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim();
  const H = headers.map(norm);
  const cDoc = H.findIndex(h => /document/.test(h)) + 1;
  const cETD = H.findIndex(h => h.includes('current') && h.includes('etd')) + 1;
  if (cDoc <= 0 || cETD <= 0) { Log.err(LOG + 'Missing "Document #" or "Current ETD"'); return; }

  // --- 6) Rewrite ETDs strictly from OOR Revised Ship Date
  const nRows = sh.getLastRow() - 1;
  const docVals = sh.getRange(2, cDoc, nRows, 1).getValues().flat();
  let changed = 0, missing = 0;

  for (let i = 0; i < nRows; i++) {
    const doc = String(docVals[i] || '').trim();
    if (!doc) continue;

    if (!byDoc.has(doc)) { missing++; continue; }

    const rawRev = byDoc.get(doc);
    const newDt  = _normalizeRevDate_(rawRev);   // → Date (same-year policy) or 'DELAYED' or null
    if (newDt instanceof Date) {
      sh.getRange(i + 2, cETD).setValue(newDt);
      changed++;
    } else if (newDt === 'DELAYED') {
      // Optional: write text or leave as-is; here we leave untouched.
    } else {
      // Optional: leave untouched; updater fallback will handle.
    }
  }

  Log.info(`${LOG}Rewrote ${changed} Current ETD cell(s) from OOR; skipped ${missing} row(s) not present in latest OOR.`);
  // Try to format (skip if typed column)
  try {
    if (nRows > 0) sh.getRange(2, cETD, nRows, 1).setNumberFormat('mmm d, yyyy');
  } catch (e) {
    if (String(e).includes('typed column')) {
      Log.warn(LOG + 'ETD is a typed column; skipped number-format.');
    } else {
      throw e;
    }
  }
}

function diagExtruflexOOR() {
  const LOG = '[diagExtruflexOOR] ';
  try {
    Log.info(LOG + 'start');

    // ---- A) Locate the latest labeled thread & list Excel attachments
    const OOR_LABEL = CONFIG.LABELS.EX_OOR;
    const ATT_RX = /^\d+\s*OOR(?:\s+Panamerica)?(?:\s*\(\d+\))?\.(xlsx|xls)$/i;

    const lbl = GmailApp.getUserLabelByName(OOR_LABEL);
    if (!lbl) { Log.err(LOG + `Label "${OOR_LABEL}" not found`); return; }

    const threads = lbl.getThreads(0, 1);
    if (!threads.length) { Log.info(LOG + 'No threads found under label'); return; }
    const th = threads[0];

    // Collect all Excel attachments (newest message first)
    const msgs = th.getMessages().sort((a,b)=>b.getDate()-a.getDate());
    const excel = [];
    msgs.forEach((m, mi) => {
      (m.getAttachments() || []).forEach((a, ai) => {
        const name = (a.getName() || '').trim();
        if (/\.(xlsx|xls)$/i.test(name)) {
          excel.push({
            msgIndex: mi,
            attIndex: ai,
            msgDate: m.getDate(),
            name: name,
            size: a.getBytes().length,
            matchesRule: ATT_RX.test(name),
            blob: a
          });
        }
      });
    });

    if (!excel.length) {
      Log.warn(LOG + 'No Excel attachments on latest thread');
      return;
    }

    Log.info(LOG + 'Excel attachments on latest thread (newest message first):');
    excel.forEach((x, i) => {
      Log.info(LOG + `  [${i}] msg@${x.msgDate.toISOString()} name="${x.name}" size=${Math.round(x.size/1024)}KB ruleMatch=${x.matchesRule}`);
    });

    // Choose attachment exactly as updater does
    let chosen = excel.find(x => x.matchesRule) || (excel.length === 1 ? excel[0] : null);
    if (!chosen) {
      Log.warn(LOG + 'No attachment matched ATT_RX; multiple Excel files exist, so no fallback chosen.');
      return;
    }
    Log.info(LOG + `Chosen attachment: "${chosen.name}" from message @ ${chosen.msgDate.toISOString()}`);

    // ---- B) Convert chosen Excel to a temp Google Sheet and read data
    let tempFileId;
    let data = null;
    try {
      tempFileId = Drive.Files.insert(
        { title: chosen.name + ' (Converted)', mimeType: MimeType.GOOGLE_SHEETS },
        chosen.blob.copyBlob()
      ).id;
      const tss = SpreadsheetApp.openById(tempFileId);
      data = tss.getSheets()[0].getDataRange().getValues();
    } finally {
      try { if (tempFileId) Drive.Files.remove(tempFileId); } catch(e) {}
    }
    if (!data || data.length < 2) { Log.warn(LOG + 'Converted sheet is empty/unreadable'); return; }

    // ---- C) Find header row/columns with the same routine the updater uses
    const syn = {
      doc:   ['document number','document no','doc number','doc no','so number','sales order number','order number'],
      rev:   ['revised ship date','new ship date','ship date','revised shipping date','expected ship date','shipdate'],
      cref:  ['customer ref','customer reference','cust ref','customerref','invoice'],
      alloc: ['date allocated','allocated','date alloc','allocation date','dateallocated']
    };
    const hdrInfo = _findHeaderRowFlex_(data, syn);
    if (hdrInfo.row === -1) {
      Log.warn(LOG + 'Could not detect a header row'); return;
    }

    const headerRow = data[hdrInfo.row] || [];
    Log.info(LOG + `Header row detected at R${hdrInfo.row+1}`);
    Log.info(LOG + 'Headers (normalized view): ' + headerRow.map(h => String(h||'').trim().toLowerCase()).join(' | '));
    Log.info(LOG + `Column indices: doc=${hdrInfo.idx.doc}, rev=${hdrInfo.idx.rev}, cref=${hdrInfo.idx.cref}, alloc=${hdrInfo.idx.alloc}`);
    if (hdrInfo.idx.doc === -1 || hdrInfo.idx.rev === -1) {
      Log.warn(LOG + 'Missing Document# or Revised Ship Date column in converted sheet');
      return;
    }

    // ---- D) Sample & parse the first N populated rows
    const N = 40; // sample size
    function fmtDate(d) { return (d instanceof Date && !isNaN(d)) ? Utilities.formatDate(d, Session.getScriptTimeZone(), 'yyyy-MM-dd') : String(d); }
    function typeOfCell(v) {
      if (v instanceof Date) return 'Date';
      if (typeof v === 'number' && isFinite(v)) return 'Number';
      if (typeof v === 'string') return 'String';
      if (v == null) return 'Blank';
      return typeof v;
    }
    function asPreview(v) {
      if (v instanceof Date) return 'Date(' + v.toDateString() + ')';
      if (typeof v === 'number') return 'Number(' + v + ')';
      if (typeof v === 'string') return JSON.stringify(v.length > 40 ? v.slice(0,40)+'…' : v);
      return String(v);
    }
    function tryYYYYMMDD(v) {
      // Accept both string "20250827" and number 20250827 as YYYYMMDD
      let s = null;
      if (typeof v === 'string' && /^\d{8}$/.test(v.trim())) s = v.trim();
      if (typeof v === 'number' && v >= 19000101 && v <= 21991231 && String(Math.floor(v)).length === 8) s = String(Math.floor(v));
      if (!s) return null;
      const y = +s.slice(0,4), m = +s.slice(4,6), d = +s.slice(6,8);
      const dt = new Date(y, m-1, d);
      return isNaN(dt) ? null : dt;
    }

    let scanned = 0, haveDoc = 0, normCount = 0, nullCount = 0, ymd8Count = 0;
    const seenKinds = { Date:0, Number:0, String:0, Blank:0, Other:0 };

    Log.info(LOG + `--- Sample of up to ${N} rows (Doc, raw→parsed) ---`);
    for (let r = hdrInfo.row + 1; r < data.length && scanned < N; r++) {
      const row = data[r] || [];
      const doc = String(row[hdrInfo.idx.doc] || '').trim();
      const rev = row[hdrInfo.idx.rev];

      if (!doc && (row.join('').trim() === '')) continue;
      scanned++;
      if (doc) haveDoc++;

      const kind = typeOfCell(rev);
      seenKinds[kind] = (seenKinds[kind] || 0) + 1;

      // What the current normalizer will do:
      const norm = _normalizeRevDate_(rev);
      if (norm instanceof Date) normCount++;
      if (!norm) nullCount++;

      // Independent probe for YYYYMMDD:
      const y8 = tryYYYYMMDD(rev);
      if (y8) ymd8Count++;

      Log.info(LOG + `R${r+1} Doc=${doc || '(blank)'} | raw=${asPreview(rev)} [${kind}] | normalize→ ${norm==='DELAYED'?'DELAYED':fmtDate(norm)} | yyyyMMdd→ ${fmtDate(y8)}`);
    }

    Log.info(LOG + `Scanned rows: ${scanned}, with Doc#: ${haveDoc}`);
    Log.info(LOG + `Raw types counts: ${Object.keys(seenKinds).map(k=>k+': '+seenKinds[k]).join(', ')}`);
    Log.info(LOG + `Parsed OK (normalize): ${normCount}, nulls: ${nullCount}, yyyyMMdd-detect: ${ymd8Count}`);

    // ---- E) Peek into the main sheet to compare a few docs
    const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
    const sh = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
    if (!sh) { Log.warn(LOG + `Main sheet "${CONFIG.SHEETS.MAIN_TAB}" not found`); return; }

    const shVals = sh.getDataRange().getValues();
    if (shVals.length < 2) { Log.info(LOG + 'Main sheet has no data'); return; }
    const H = shVals[0].map(h => String(h||'').toLowerCase());
    const iDoc = H.findIndex(h => h.includes('document'));
    const iETD = H.findIndex(h => h.includes('current') && h.includes('etd'));
    if (iDoc === -1 || iETD === -1) { Log.warn(LOG + 'Main sheet missing Document # or Current ETD'); return; }

    // Build quick doc→currentETD map
    const mapMain = new Map();
    for (let r = 1; r < shVals.length; r++) {
      const doc = String(shVals[r][iDoc] || '').trim();
      if (!doc) continue;
      mapMain.set(doc, shVals[r][iETD]);
    }

    // Rebuild a small OOR doc→raw map from the same converted data for comparison
    const mapOOR = new Map();
    for (let r = hdrInfo.row + 1; r < data.length; r++) {
      const doc = String((data[r][hdrInfo.idx.doc] || '')).trim();
      if (!doc) continue;
      const raw = data[r][hdrInfo.idx.rev];
      if (!mapOOR.has(doc)) mapOOR.set(doc, raw);
    }

    let shown = 0;
    Log.info(LOG + '--- Cross-check (first 25 in both OOR & Main) ---');
    for (const [doc, raw] of mapOOR) {
      if (!mapMain.has(doc)) continue;
      const norm = _normalizeRevDate_(raw);
      const cur  = mapMain.get(doc);
      const curTxt = (cur instanceof Date) ? cur.toDateString() : String(cur||'(blank)');
      Log.info(LOG + `Doc ${doc}: OOR raw=${asPreview(raw)} → normalize=${norm==='DELAYED'?'DELAYED':fmtDate(norm)} | main.CurrentETD=${curTxt}`);
      shown++;
      if (shown >= 25) break;
    }

    Log.info(LOG + 'done');
  } catch (e) {
    Log.err(LOG + 'Error: ' + (e && e.stack ? e.stack : e));
  }
}

/**
 * Backfill blank ETDs (column L) on "Extruflex" using up to N recent OOR snapshots.
 * - Uses same header detection + date normalizer as updateExtruflexETDs().
 * - Only fills BLANK ETD cells; never overwrites a non-blank ETD.
 * - Default order is NEWEST→OLDEST, so results are as current as possible.
 */
/**
 * Backfill blank ETDs (column L) AND update Document # via BP Reference match:
 *   OOR Invoice# → "2363-" + Invoice# → match Tracking Log col B (BP Reference No.)
 *   → take col C (Document Number) → write into main sheet's "Document #".
 *
 * Options:
 *   - maxSnapshots: number   (default 10)
 *   - order: 'newest-first' | 'oldest-first'  (default 'newest-first')
 */
function backfillETDFromPriorOORs(options) {
  const LOG = '[backfillETD] ';
  const MAX_SNAPSHOTS    = (options && options.maxSnapshots) || 10;
  const ORDER            = (options && options.order) || 'newest-first';

  const MAX_THREADS_SCAN = 60;
  const OOR_LABEL = CONFIG.LABELS.EX_OOR;
  const ATT_RX    = /^\d+\s*OOR(?:\s+Panamerica)?(?:\s*\(\d+\))?\.(xlsx|xls)$/i;

  Log.info(LOG + 'start');

  // ---- A) Collect most-recent OOR Excel attachments
  const lbl = GmailApp.getUserLabelByName(OOR_LABEL);
  if (!lbl) return Log.err(LOG + `Label "${OOR_LABEL}" not found`);

  const threads = lbl.getThreads(0, MAX_THREADS_SCAN); // newest first
  const all = [];
  const seen = new Set(); // dedupe by name|size

  threads.forEach(th => {
    th.getMessages().sort((a,b)=>b.getDate()-a.getDate()).forEach(m => {
      (m.getAttachments() || []).forEach(att => {
        const name = (att.getName() || '').trim();
        if (!ATT_RX.test(name)) return;
        const key = name + '|' + att.getBytes().length;
        if (seen.has(key)) return;
        seen.add(key);
        all.push({ name, blob: att.copyBlob(), msgDate: m.getDate() });
      });
    });
  });

  if (!all.length) return Log.info(LOG + 'No OOR Excel attachments found across recent threads');

  all.sort((a,b)=>b.msgDate - a.msgDate);
  let picks = all.slice(0, Math.max(1, MAX_SNAPSHOTS));
  if (ORDER === 'oldest-first') picks = picks.reverse();

  Log.info(LOG + `Using ${picks.length} snapshot(s) in order: ` +
          picks.map(x => `${Utilities.formatDate(x.msgDate, Session.getScriptTimeZone(), 'yyyy-MM-dd')} "${x.name}"`).join('  →  '));

  // ---- B) Open main sheet + locate columns (Invoice, Document #, ETD=L)
  const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const sh = ss.getSheetByName(CONFIG.SHEETS.MAIN_TAB);
  if (!sh) return Log.err(LOG + `Main sheet "${CONFIG.SHEETS.MAIN_TAB}" not found`);
  const lastRow = sh.getLastRow();
  if (lastRow < 2) return Log.info(LOG + 'No data rows to backfill');

  const headers = sh.getRange(1,1,1, sh.getLastColumn()).getValues()[0].map(h => String(h||''));
  const Hlc     = headers.map(h => h.toLowerCase());
  const cInv = Hlc.findIndex(h => h.includes('invoice')) + 1;
  const cDoc = Hlc.findIndex(h => h.includes('document')) + 1;
  if (cDoc <= 0) return Log.err(LOG + 'Cannot find "Document" column');
  if (cInv <= 0) return Log.err(LOG + 'Cannot find "Invoice" column');

  const cETD = 12; // Column L explicit
  if (cETD > sh.getLastColumn()) return Log.err(LOG + 'Column L (ETD) is outside the current sheet range');

  const n = lastRow - 1;
  const invVals = sh.getRange(2, cInv, n, 1).getValues().flat().map(v => v == null ? '' : String(v).trim());
  const docVals = sh.getRange(2, cDoc, n, 1).getValues().flat();
  const etdVals = sh.getRange(2, cETD, n, 1).getValues().flat();

  // Build Invoice# → row index list (handle duplicates & leading zeros)
  const invToRows = new Map();
  invVals.forEach((val, i) => {
    if (!val) return;
    const k1 = val;
    const k2 = val.replace(/^0+/, '') || '0';
    if (!invToRows.has(k1)) invToRows.set(k1, []);
    invToRows.get(k1).push(i);
    if (k2 !== k1) {
      if (!invToRows.has(k2)) invToRows.set(k2, []);
      invToRows.get(k2).push(i);
    }
  });

  // Pull BP Reference → Document Number from Tracking Log (col B → col C)
  const bpToDoc = _bpRefToDocMapFromTrackingLog_(ss);

  const isBlankETD = v => (v === '' || v === null);
  let totalFilledETD = 0;
  let totalDocUpdates = 0;

  // ---- C) Process each snapshot: backfill ETD + sync Document # via BP Reference match
  picks.forEach((snap, idx) => {
    const tag = `snap#${idx+1}`;
    let tempId;
    try {
      // Convert Excel to temp Google Sheet
      tempId = Drive.Files.insert(
        { title: snap.name + ' (Converted)', mimeType: MimeType.GOOGLE_SHEETS },
        snap.blob
      ).id;
      const tss = SpreadsheetApp.openById(tempId);
      const data = tss.getSheets()[0].getDataRange().getValues();
      if (!data || data.length < 2) { Log.warn(LOG + `${tag}: empty/unreadable`); return; }

      // Find columns
      const syn = {
        doc: ['document number','document no','doc number','doc no','so number','sales order number','order number'],
        rev: ['revised ship date','new ship date','ship date','revised shipping date','expected ship date','shipdate'],
        inv: ['invoice #','invoice no','invoice number','invoice','inv #','inv no','inv']
      };
      const hdrInfo = _findHeaderRowFlex_(data, { doc:syn.doc, rev:syn.rev, cref:[], alloc:[] });
      // (we'll locate INV separately for clarity)
      const headerRow = hdrInfo.row >= 0 ? data[hdrInfo.row] : data[0];
      const headerNorm = (headerRow || []).map(v => String(v||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim());
      const iDoc = hdrInfo.idx.doc;
      const iRev = hdrInfo.idx.rev;
      const iInv = (() => {
        for (let j=0;j<headerNorm.length;j++) {
          if (syn.inv.includes(headerNorm[j])) return j;
        }
        return -1;
      })();

      if (iDoc === -1) Log.warn(LOG + `${tag}: missing Document column`);
      if (iInv === -1) Log.warn(LOG + `${tag}: missing Invoice column in OOR snapshot`);

      // ---- (1) Build doc → latest ETD (if available) and backfill blanks in main sheet
      if (iDoc !== -1 && iRev !== -1) {
        const docToDate = new Map();
        for (let r = hdrInfo.row + 1; r < data.length; r++) {
          const row = data[r] || [];
          const doc = String(row[iDoc] || '').trim();
          if (!doc) continue;
          const raw = row[iRev];
          const dt  = _normalizeRevDate_(raw);
          if (dt instanceof Date) {
            const prev = docToDate.get(doc);
            if (!prev || (dt > prev)) docToDate.set(doc, dt);
          }
        }
        let filledThis = 0;
        if (docToDate.size) {
          for (let i = 0; i < n; i++) {
            if (!isBlankETD(etdVals[i])) continue;
            const doc = String(docVals[i] || '').trim();
            if (!doc) continue;
            const dt = docToDate.get(doc);
            if (!(dt instanceof Date)) continue;
            sh.getRange(i + 2, cETD).setValue(dt);
            etdVals[i] = dt;
            filledThis++;
          }
          if (filledThis) {
            try { sh.getRange(2, cETD, n, 1).setNumberFormat('mmm d, yyyy'); } catch(_) {}
          }
        }
        totalFilledETD += filledThis;
        Log.info(LOG + `${tag}: filled ${filledThis} blank ETD(s)`);
      }

      // ---- (2) Invoice → BP Reference → Document Number → update main sheet's Document #
      if (iInv !== -1 && bpToDoc.size) {
        let docUpdatesThis = 0;

        for (let r = hdrInfo.row + 1; r < data.length; r++) {
          const row = data[r] || [];
          let invRaw = row[iInv];
          if (invRaw == null || invRaw === '') continue;

          let invTxt = _asText_(invRaw);              // keep suffixes like "-RO"
          if (!invTxt) continue;

          // Build BP Reference: add prefix if not already there
          let bpRef = invTxt.trim();
          bpRef = (/^2363-/i.test(bpRef)) ? bpRef : `2363-${bpRef}`;

          const docFromTracking = bpToDoc.get(bpRef.trim());
          if (!docFromTracking) continue;

          // Update all rows in main sheet where Invoice matches invTxt (w/ leading-zero alias)
          const k1 = invTxt;
          const k2 = invTxt.replace(/^0+/, '') || '0';
          const rows = (invToRows.get(k1) || []).concat(invToRows.get(k2) || []);
          if (!rows.length) continue;

          rows.forEach(iRow => {
            const curDoc = String(docVals[iRow] == null ? '' : docVals[iRow]).trim();
            if (curDoc !== docFromTracking) {
              sh.getRange(iRow + 2, cDoc).setValue(docFromTracking);
              docVals[iRow] = docFromTracking;
              docUpdatesThis++;
            }
          });
        }

        totalDocUpdates += docUpdatesThis;
        Log.info(LOG + `${tag}: updated ${docUpdatesThis} Document #(s) via Tracking Log matches`);
      }
    } catch (e) {
      Log.err(LOG + `${tag}: error ${e}`);
    } finally {
      try { if (tempId) Drive.Files.remove(tempId); } catch(_) {}
    }
  });

  Log.info(LOG + `done — ETDs filled: ${totalFilledETD}, Doc# updated: ${totalDocUpdates}`);
}



/**
 * Build a Map from "BP Reference No." (col B) → "Document Number" (col C)
 * on the "Tracking Log" sheet. Trims text; first-seen wins (sheet is usually newest-first).
 */
function _bpRefToDocMapFromTrackingLog_(ss) {
  const map = new Map();
  const sh = ss.getSheetByName('Tracking Log');
  if (!sh || sh.getLastRow() < 2) return map;

  const data = sh.getDataRange().getValues();
  const H = (data[0] || []).map(h => String(h||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim());
  let iBP  = H.findIndex(h => h === 'bp reference no' || h === 'bp reference number' || h === 'bp reference');
  let iDoc = H.findIndex(h => h === 'document number' || h === 'document #');

  // Fallback to known columns if headers aren’t perfect
  if (iBP  === -1 && data[0].length >= 2) iBP  = 1; // column B (0-based)
  if (iDoc === -1 && data[0].length >= 3) iDoc = 2; // column C (0-based)

  if (iBP === -1 || iDoc === -1) return map;

  // Iterate top→down, keep first occurrence (log is generally newest-first)
  for (let r = 1; r < data.length; r++) {
    const bp  = _asText_(data[r][iBP]);
    const doc = _asText_(data[r][iDoc]);
    if (!bp || !doc) continue;
    if (!map.has(bp)) map.set(bp, doc);
  }
  return map;
}

function _rebuildTrackingCache_() {
  const ss = SpreadsheetApp.openById(CONFIG.SHEETS.MAIN_ID);
  const want = (name) => name === 'Tracking Log' || /^Tracking -\s*\d{6}\b/i.test(name);
  const docs = new Set();

  ss.getSheets().forEach(tab => {
    const nm = tab.getName();
    if (!want(nm)) return;

    const vals = tab.getDataRange().getValues();
    if (!vals || vals.length < 2) return;

    const H = vals[0].map(h => String(h||'').toLowerCase().replace(/[^a-z0-9]+/g,' ').trim());
    const iDoc = H.findIndex(h =>
      ['document number','document#','document #','doc number','so number','order number'].includes(h)
    );
    if (iDoc === -1) return;

    for (let r = 1; r < vals.length; r++) {
      const d = String(vals[r][iDoc] || '').trim();
      if (d) docs.add(d);
    }
  });

  const cache = ss.getSheetByName('Tracking Cache') || ss.insertSheet('Tracking Cache');
  cache.clearContents();
  cache.getRange(1,1).setValue('Document #');
  if (docs.size) cache.getRange(2,1,docs.size,1).setValues(Array.from(docs).map(d => [d]));
}

function fixEstimatedShipDates(options = {}) {
  const LOG = '[fixEstimatedShipDates] ';
  const ssId   = options.ssId   || CONFIG.SHEETS.MAIN_ID;
  const tab    = options.tab    || CONFIG.SHEETS.MAIN_TAB; // "Extruflex"
  const header = options.header || 'Est Ship';              // also checks "Estimated Ship"
  const allowedMonths = options.allowedMonths || [8, 9];    // Aug, Sep (1=Jan)
  const allowedYear   = options.allowedYear   || 2025;      // adjust as needed
  const columnFallback = 6;                                 // F if header not found

  const ss = SpreadsheetApp.openById(ssId);
  const sh = ss.getSheetByName(tab);
  if (!sh) { Log.err(LOG + `Sheet "${tab}" not found`); return 0; }
  const lastRow = sh.getLastRow();
  if (lastRow < 2) { Log.info(LOG + 'No data rows'); return 0; }

  // Locate the column by header; fallback to F
  const headerMap = _getHeaderMap_(sh);
  let col = _colByHeader_(headerMap, sh, header, /*createIfMissing*/ false);
  if (col <= 0) {
    // try common variant
    col = _colByHeader_(headerMap, sh, 'Estimated Ship', false);
  }
  if (col <= 0) col = columnFallback;

  const rng = sh.getRange(2, col, lastRow - 1, 1);
  const vals = rng.getValues();

  const toY2K = (yy) => 2000 + (yy|0); // "25" → 2025
  const mkDate = (y,m,d) => {
    const dt = new Date(y, m - 1, d);
    return isNaN(dt) ? null : new Date(dt.getFullYear(), dt.getMonth(), dt.getDate());
  };

  // Try strict dd/mm/yy and mm/dd/yy interpretations
  const tryDMY = (s) => {
    const m = String(s).trim().match(/^(\d{1,2})[\/\.\-](\d{1,2})[\/\.\-](\d{2})$/);
    if (!m) return null;
    const dd = +m[1], mm = +m[2], yy = +m[3];
    return mkDate(toY2K(yy), mm, dd);
  };
  const tryMDY = (s) => {
    const m = String(s).trim().match(/^(\d{1,2})[\/\.\-](\d{1,2})[\/\.\-](\d{2})$/);
    if (!m) return null;
    const mm = +m[1], dd = +m[2], yy = +m[3];
    return mkDate(toY2K(yy), mm, dd);
  };

  // Use the canonical normalizer you already have for richer cases
  const norm = (v) => {
    // Reuse your robust normalizer
    const d = _normalizeRevDate_(v); // Date | 'DELAYED' | null
    return (d instanceof Date) ? d : null;
  };

  // Decide which interpretation is "correct" for this cleanup pass:
  const chooseAllowed = (dA, dB) => {
    const okA = dA && dA.getFullYear() === allowedYear && allowedMonths.includes(dA.getMonth() + 1);
    const okB = dB && dB.getFullYear() === allowedYear && allowedMonths.includes(dB.getMonth() + 1);
    if (okA && !okB) return dA;
    if (okB && !okA) return dB;
    if (okA && okB)  return dA; // arbitrary but stable
    return null;
  };

  let changed = 0, formatted = 0;

  for (let i = 0; i < vals.length; i++) {
    const v = vals[i][0];

    // Already a proper Date? Just ensure format later.
    if (v instanceof Date && !isNaN(v)) continue;

    // Try robust normalizer first (handles Excel serials, yyyyMMdd, "27 Aug", etc.)
    let d = norm(v);

    // If still unresolved and looks like 2-digit year with two slashes, test both ways.
    if (!d && typeof v === 'string' && /^\d{1,2}[\/\.\-]\d{1,2}[\/\.\-]\d{2}$/.test(v.trim())) {
      const dmy = tryDMY(v); // dd/mm/yy
      const mdy = tryMDY(v); // mm/dd/yy
      d = chooseAllowed(dmy, mdy) || dmy || mdy; // prefer allowed month; else any plausible
    }

    if (d instanceof Date) {
      vals[i][0] = d; // write back as a typed Date
      changed++;
    } else {
      // Leave as-is if truly unparseable
    }
  }

  // Write any corrections
  if (changed) rng.setValues(vals);

  // Enforce an unambiguous display format on the whole column
  try {
    sh.getRange(2, col, Math.max(0, lastRow - 1), 1).setNumberFormat('mmm dd, yyyy');
    formatted = lastRow - 1;
  } catch (_) {}

  Log.info(`${LOG}Converted ${changed} cell(s) to typed Date. Enforced format on ${formatted} cell(s).`);
  return changed;
}

/**
 * Optional: run both ETD and Estimated-Ship cleanups together.
 * Safe to call after confirmExtruflexPOs() or updateExtruflexETDs().
 */
function repairDatesNow() {
  repairExtruflexCurrentETDs(); // you already have this
  fixEstimatedShipDates({ allowedMonths: [8,9], allowedYear: 2025 });
}